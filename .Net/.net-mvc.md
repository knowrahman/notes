
## What is .NET MVC?

**.NET MVC** is a design pattern-based framework for building web applications using **ASP.NET**, part of the .NET ecosystem. It separates the application into three main components:

1. **Model** – Represents the application’s data and business logic.
2. **View** – UI logic of the application; what the user sees.
3. **Controller** – Handles user input, interacts with the model, and selects the view to render.

---

### MVC Architecture: Overview

```
           +------------+        +--------+        +---------+
  User --> | Controller | -----> | Model  | -----> | Database|
           +------------+        +--------+        +---------+
                 |
                 v
              +------+
              | View |
              +------+
```

---

### Component Breakdown

#### 1. **Model**
- Contains **data** and **business logic**.
- Typically represented by C# classes.
- Uses **Entity Framework** or other ORMs for DB interactions.

Example:
```csharp
public class Product {
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

#### 2. **View**
- HTML + Razor syntax (`.cshtml` files).
- No business logic, only display logic.
- Uses **Razor engine** to combine HTML with C#.

Example:
```cshtml
<h2>@Model.Name</h2>
<p>Price: @Model.Price</p>
```

#### 3. **Controller**
- Handles user input via HTTP requests.
- Interacts with the model.
- Returns a `View()` or `RedirectToAction()`.

Example:
```csharp
public class ProductController : Controller {
    public IActionResult Details(int id) {
        var product = _context.Products.Find(id);
        return View(product);
    }
}
```

---

### Important Concepts You Should Know

| Concept                      | Description |
|-----------------------------|-------------|
| **Routing**                 | Maps URL patterns to controller actions. Uses `Startup.cs` or `RouteConfig.cs` in older versions. |
| **Action Methods**          | Public methods inside a controller that respond to URL requests. |
| **ViewModel**               | Custom object passed from Controller to View to avoid exposing data models directly. |
| **TempData / ViewBag / ViewData** | Used to pass data between controller and view (or between actions). |
| **Partial Views**           | Reusable UI components like navbars, footers, etc. |
| **Data Annotations**        | Used for validation like `[Required]`, `[StringLength]`, etc. |
| **Scaffolding**             | Auto-generates controllers and views from models for CRUD operations. |
| **Filters**                 | Code executed before/after action methods (e.g., for authentication). |

---

### Tools & Technologies Commonly Used with .NET MVC

- **Visual Studio** (IDE)
- **SQL Server** (default DB)
- **Entity Framework** (ORM)
- **Bootstrap** (for front-end)
- **Identity** (for authentication)
- **LINQ** (for querying)

---

### How to Learn .NET MVC – Step-by-Step Plan

#### Step 1: Understand the Basics
- Learn C# fundamentals (if not already).
- Understand what MVC pattern is conceptually.

#### Step 2: Set Up Environment
- Install **Visual Studio Community Edition**.
- Create a new **ASP.NET Web Application** and choose **MVC template**.

#### Step 3: Build a Simple CRUD App
- Build something simple like a **product catalog** or **blog**.
- Use scaffolding to auto-generate views and controllers.

#### Step 4: Dive into Advanced Topics
- Custom routing
- Middleware (if using ASP.NET Core)
- Dependency injection
- Authorization and roles

#### Step 5: Debugging and Logging
- Use breakpoints to understand control flow.
- Integrate logging (Serilog or built-in logging).

#### Step 6: Deploy a Project
- Deploy to IIS or Azure.
- Use EF migrations for database updates.

---

### Exam Power-Ups (Memory Aids)

- **MVC = Separation of Concerns** – UI (View), Logic (Model), Input Handling (Controller).
- **Controller → Model → View** is the typical flow.
- **ActionResult** is what Controllers return, can be `View()`, `Redirect()`, `Json()`, etc.
- **ViewModel** = Shape the data **for display only**.

---

## 1. .NET MVC Folder and File Structure

When you create a new **ASP.NET Core MVC** project, the typical structure looks like this:

```
MyMvcApp/
│
├── Controllers/
│   └── HomeController.cs
│
├── Models/
│   └── Product.cs
│
├── Views/
│   ├── Home/
│   │   └── Index.cshtml
│   └── Shared/
│       ├── _Layout.cshtml
│       └── _ValidationScriptsPartial.cshtml
│
├── wwwroot/
│   ├── css/
│   ├── js/
│   └── lib/
│
├── Program.cs
├── appsettings.json
├── Startup.cs (older versions only)
├── MyMvcApp.csproj
```

### Folders:

| Folder | Purpose |
|--------|---------|
| **Controllers/** | Contains C# classes that handle incoming HTTP requests and return responses. |
| **Models/** | Holds business/domain models — C# classes used to represent and manipulate data. |
| **Views/** | Contains UI files (`.cshtml`) rendered to the browser. Organized by controller name. |
| **Views/Shared/** | Contains layout files and shared partial views like navbars, footers, etc. |
| **wwwroot/** | The web root — serves static files (JS, CSS, images). |
| **appsettings.json** | Configuration file (e.g., connection strings, app settings). |
| **Program.cs** | Main entry point to the application. |
| **Startup.cs** | Used in .NET Core 3.1 and below for service configuration. Merged into `Program.cs` in .NET 6+. |

---

## 2. Execution Flow in ASP.NET Core MVC

Let’s walk through how a request is handled:

```
Browser sends a request → Middleware pipeline → Routing → Controller → Action → View → Response
```

### Step-by-Step Execution Flow:

1. **Program.cs** runs and sets up the web host.
2. Middleware (like authentication, static file serving, etc.) is configured and executed.
3. **Routing Middleware** maps the URL to a controller and action.
4. The **Controller** handles the request.
5. The **Action Method** runs logic and returns a `View()`, `Redirect()`, or `Json()`.
6. If it returns `View()`, Razor combines the `.cshtml` with data and renders HTML.
7. HTML response goes back to the browser.

---

## 3. `Program.cs` Explained (for .NET 6+)

In .NET 6 and newer, `Program.cs` uses the **minimal hosting model**, and it looks like this:

```csharp
var builder = WebApplication.CreateBuilder(args);

// Register services to the container
builder.Services.AddControllersWithViews();

var app = builder.Build();

// Configure middleware pipeline
if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

// Configure endpoints (routes)
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
```

### Detailed Breakdown:

| Code | Purpose |
|------|---------|
| `CreateBuilder()` | Initializes app with default configuration, logging, and dependency injection. |
| `AddControllersWithViews()` | Adds MVC services (controller + view engine) to DI container. |
| `Build()` | Compiles the app and makes it ready to handle HTTP requests. |
| `UseHttpsRedirection()` | Redirects HTTP requests to HTTPS. |
| `UseStaticFiles()` | Serves files from `wwwroot/`. |
| `UseRouting()` | Enables routing middleware. |
| `UseAuthorization()` | Adds authorization middleware. |
| `MapControllerRoute(...)` | Sets up conventional routing (`controller/action/id`). |
| `Run()` | Starts the app and begins listening for requests. |

---

### How to Think About It:

- `builder.Services` is where you register dependencies (DI).
- `app.Use...()` is the middleware pipeline.
- `app.Map...()` is for defining routing behavior.
- `app.Run()` boots up the app.

---

## Exam Power-Ups (Memory Aids)

- Think of `Program.cs` as your **startup script** that glues everything together.
- `Controllers`, `Models`, and `Views` represent **request processing**, **data**, and **UI**.
- Execution Flow: **Program → Middleware → Routing → Controller → Action → View → Browser**.

---





## Difference Between **Solution** and **Project** in .NET

| Feature            | **Solution (.sln)**                                      | **Project (.csproj / .vbproj / .fsproj)**                  |
|--------------------|----------------------------------------------------------|------------------------------------------------------------|
| **Definition**      | A container that groups one or more related projects     | A single application or library with source code & configs |
| **File Extension**  | `.sln`                                                   | `.csproj` (C#), `.vbproj` (VB), `.fsproj` (F#)             |
| **Purpose**         | Manages and organizes multiple projects together         | Defines how to build, compile, and run a specific program  |
| **Scope**           | Solution-level settings, dependencies across projects    | Contains files, references, and settings for one app       |
| **Example Use**     | E-commerce solution with frontend, backend, and shared library projects | ASP.NET MVC web app, class library, or console app         |
| **Tools**           | Used by **Visual Studio** to show a workspace            | Used by **MSBuild** to build and run the app               |

---

## Analogy to Understand It

- **Solution** is like a **folder** containing different **projects** (apps, services, libraries).
- Think of a **Project** as one **building**, and the **Solution** as the **city block** that holds multiple buildings (each with its own purpose).

---

## Example:

Let’s say you’re building an enterprise e-commerce app.

```
ECommerceApp.sln
├── ECommerce.Web.csproj        (ASP.NET MVC frontend)
├── ECommerce.API.csproj        (Web API backend)
├── ECommerce.Core.csproj       (Class library for shared models and services)
├── ECommerce.Tests.csproj      (Unit test project)
```

- `ECommerceApp.sln` helps Visual Studio load all these together.
- Each `.csproj` builds a separate component.

---

## Where Are They Created?

- When you create a solution from Visual Studio:  
  `File → New → Project → Create new solution or add to existing`.

- From CLI:
```bash
dotnet new sln -n ECommerceApp
dotnet new mvc -n ECommerce.Web
dotnet sln add ECommerce.Web/ECommerce.Web.csproj
```

---

## Exam Power-Ups (Memory Aids)

- `.sln = Solution = Organizer of multiple projects`
- `.csproj = Project = One buildable app/library`
- Use **solution** when managing **multiple interdependent parts** of an app.
- Use **project** when focusing on one **unit of code to compile and run**.

---


## CSPROJ

## What is `.csproj`?

`.csproj` is an **XML-based file** used by MSBuild that defines:

- The **target framework**
- Project **dependencies**
- **Build settings**
- **Output configuration**
- **Runtime settings**
- Launch and debug profiles (indirectly via `launchSettings.json`)

This file is essential because it controls **how** and **what** gets built and run.

---

## Sample `.csproj` File

```xml
<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.EntityFrameworkCore.SqlServer" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

</Project>
```

---

### Detailed Breakdown

#### `<Project Sdk="Microsoft.NET.Sdk.Web">`
- Specifies the **project type** and **build tools** to use.
- Common SDKs:
  - `Microsoft.NET.Sdk` – Console/Library apps
  - `Microsoft.NET.Sdk.Web` – Web apps (MVC, Razor, Blazor)
  - `Microsoft.NET.Sdk.Razor` – Razor components like Blazor UI libraries

---

### `<PropertyGroup>` Elements

| Property | Description |
|----------|-------------|
| `TargetFramework` | .NET version (`net8.0`, `net7.0`, etc.) |
| `Nullable` | Enables nullable reference types (`enable/disable`) |
| `OutputType` | Specifies if the output is `Exe` or `Library` |
| `AspNetCoreHostingModel` | `InProcess` or `OutOfProcess` for hosting in IIS |
| `LangVersion` | Forces C# language version |
| `ImplicitUsings` | Auto-imports namespaces in .NET 6+ |
| `GenerateDocumentationFile` | Adds XML doc generation during build |

---

### `<ItemGroup>` Elements

Used to include dependencies and other items.

#### Example: NuGet Packages
```xml
<ItemGroup>
  <PackageReference Include="AutoMapper" Version="12.0.0" />
</ItemGroup>
```

#### Example: Project Reference
```xml
<ItemGroup>
  <ProjectReference Include="..\MyApp.Core\MyApp.Core.csproj" />
</ItemGroup>
```

#### Example: Static Files
```xml
<ItemGroup>
  <Content Include="Assets\logo.png">
    <CopyToOutputDirectory>Always</CopyToOutputDirectory>
  </Content>
</ItemGroup>
```

---

## What About Profiles?

There are two meanings of "profile" in the .NET ecosystem:

### 1. **Build Configuration Profiles**

These come from `PropertyGroup` using a `Condition`.

```xml
<PropertyGroup Condition="'$(Configuration)' == 'Debug'">
  <DefineConstants>DEBUG</DefineConstants>
  <Optimize>false</Optimize>
</PropertyGroup>

<PropertyGroup Condition="'$(Configuration)' == 'Release'">
  <Optimize>true</Optimize>
</PropertyGroup>
```

You switch these profiles using:
```bash
dotnet build -c Release
```

---

### 2. **Launch Profiles** (`launchSettings.json`)

This file is **not inside `.csproj`**, but it **defines how to run/debug** your app.

Located in:
```
Properties/launchSettings.json
```

Example:
```json
{
  "profiles": {
    "MyMvcApp": {
      "commandName": "Project",
      "launchBrowser": true,
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

#### Fields:

| Field | Meaning |
|-------|---------|
| `commandName` | `"Project"` = run the app, `"IISExpress"` = debug in IIS |
| `applicationUrl` | Where the app runs |
| `environmentVariables` | Set values like `ASPNETCORE_ENVIRONMENT` here |

Switch profile in Visual Studio using the **dropdown menu** on top.

---

## Exam Power-Ups (Memory Aids)

- `.csproj` tells the **compiler** how to build and what dependencies to include.
- `launchSettings.json` tells the **debugger** how to run and launch the app.
- Use `Condition="'$(Configuration)' == 'Debug'"` to define **custom build behavior** for debug/release.
- Use `ProjectReference` to link **internal libraries**, and `PackageReference` for **external NuGet packages**.

---

## What is `launchSettings.json`?

It’s a JSON file located in:

```
/Properties/launchSettings.json
```

This file configures:

- **Which environment** your app runs in (e.g., Development, Production)
- **What ports** it listens on
- **Whether the browser should open**
- **What debugger or server** (Kestrel, IIS Express, etc.) to use
- **Custom environment variables**

It’s **only used during development** and **does not affect production deployments**.

---

## Structure of `launchSettings.json`

Here’s a sample:

```json
{
  "profiles": {
    "MyMvcApp": {
      "commandName": "Project",
      "dotnetRunMessages": true,
      "launchBrowser": true,
      "applicationUrl": "https://localhost:5001;http://localhost:5000",
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development",
        "MyApp_CustomKey": "MyValue"
      }
    },
    "IIS Express": {
      "commandName": "IISExpress",
      "launchBrowser": true,
      "environmentVariables": {
        "ASPNETCORE_ENVIRONMENT": "Development"
      }
    }
  }
}
```

---

## Explanation of Key Fields

| Key | Description |
|-----|-------------|
| `profiles` | A dictionary of **named profiles** (ways to run the app). |
| `commandName` | Defines how the app is started. Can be: <ul><li>`Project` – launches via `dotnet run`</li><li>`IISExpress` – uses IIS Express for debugging</li><li>`Executable` – runs a custom exe</li></ul> |
| `launchBrowser` | `true` means your browser will automatically open at launch. |
| `applicationUrl` | The URLs (HTTP/HTTPS) the app listens on. |
| `environmentVariables` | Key-value pairs used to configure runtime behavior (e.g., `ASPNETCORE_ENVIRONMENT`). |
| `dotnetRunMessages` | Shows run messages in the console (for .NET CLI). |

---

## When You Use It

- When running the app from **Visual Studio** (dropdown selector)
- When using `dotnet run` and you want it to respect ports/URLs
- When debugging with environment-specific behavior

---

## How to Add a New Launch Profile

If you want to create a custom profile (e.g., with staging environment), add a new section:

```json
"StagingProfile": {
  "commandName": "Project",
  "launchBrowser": true,
  "applicationUrl": "https://localhost:7001;http://localhost:7000",
  "environmentVariables": {
    "ASPNETCORE_ENVIRONMENT": "Staging"
  }
}
```

Then run using:

```bash
dotnet run --launch-profile StagingProfile
```

---

## Where It's Referenced

- `launchSettings.json` is used **automatically** by Visual Studio.
- CLI: only when you explicitly pass `--launch-profile`.

---

## Common Use Case: Environment Switching

```csharp
if (env.IsDevelopment()) {
    app.UseDeveloperExceptionPage();
} else {
    app.UseExceptionHandler("/Home/Error");
}
```

This depends on:
```json
"ASPNETCORE_ENVIRONMENT": "Development"
```

Change it to `Production`, and your error pages and logging will change accordingly.

---

## Exam Power-Ups (Memory Aids)

- `launchSettings.json` is for **local dev only** – it doesn’t go to production.
- Use `"Project"` to launch with `dotnet run`, `"IISExpress"` to use IIS Express.
- Environment variables like `ASPNETCORE_ENVIRONMENT` drive **runtime behavior** (e.g., config files, error pages).
- To test different environments: change the profile or pass `--environment` manually.

---


The command to install all dependencies (NuGet packages) for a .NET project is:

```bash
dotnet restore
```

### What it does:
- Reads your `.csproj` or `.sln` file.
- Downloads all missing packages listed under `<PackageReference>` from NuGet.
- Populates the `obj/` and `bin/` directories with necessary build assets.

---

### Typical Use Cases:
- After cloning a repository
- After editing the `.csproj` manually
- After switching branches with different dependencies

---

### Optional Usage with Solution:
```bash
dotnet restore YourSolution.sln
```

Or for a specific project:

```bash
dotnet restore path/to/YourProject.csproj
```

---

### Tip:
`dotnet build` and `dotnet run` automatically perform a restore if needed, but it's best practice to run `dotnet restore` manually after pulling code or switching branches.


