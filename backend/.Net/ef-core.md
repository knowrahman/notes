1. **Getting Started**
   - What is EF Core and why use it?
   - Installing EF Core in a .NET project
   - Creating a basic model and DbContext

2. **Database Operations (CRUD)**
   - Creating and applying migrations
   - Inserting, updating, deleting, and querying data
   - Tracking vs. No Tracking queries

3. **Relationships**
   - One-to-One, One-to-Many, and Many-to-Many
   - Navigation properties and Fluent API

4. **Advanced Features**
   - Query filters, shadow properties, raw SQL
   - Transactions, concurrency handling, value conversions

5. **Performance Tuning**
   - Caching, compiled queries, splitting queries
   - Using projections and avoiding N+1 problems

6. **Real-World Application**
   - EF Core in ASP.NET Core with repositories/services
   - Unit testing with EF Core (InMemory provider)
   - Tips for production: connection pooling, migrations in CI/CD


Perfect, Rahman. Let’s switch gears and walk through the **Database First (Schema First)** approach in EF Core. This is ideal when you already have an existing database and want to scaffold your models and `DbContext` from it.

---

## Database First (Schema First) in EF Core

### 1. Requirements

Make sure you have the following packages installed:

```bash
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
```

And install this if you're using PostgreSQL:

```bash
dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL
```

---

### 2. Basic Syntax to Scaffold Models from DB

```bash
dotnet ef dbcontext scaffold "Your_Connection_String" Microsoft.EntityFrameworkCore.SqlServer -o Models
```

- Replace `"Your_Connection_String"` with your actual DB connection.
- `Microsoft.EntityFrameworkCore.SqlServer` is the provider.
- `-o Models` tells EF to place all the generated classes in the `Models/` folder.

---

### 3. Example: SQL Server DB

Suppose you already have a `Product` and `Category` table in your SQL Server database.

Here’s the command you would run:

```bash
dotnet ef dbcontext scaffold "Server=localhost;Database=EfCoreDemoDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -o Models
```

---

### 4. Result: Auto-Generated Code

EF Core will generate:

#### `Models/Product.cs`

```csharp
public partial class Product
{
    public int Id { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public int? CategoryId { get; set; }

    public virtual Category? Category { get; set; }
}
```

#### `Models/Category.cs`

```csharp
public partial class Category
{
    public int Id { get; set; }
    public string Name { get; set; } = null!;

    public virtual ICollection<Product> Products { get; set; } = new List<Product>();
}
```

#### `AppDbContext.cs`

```csharp
public partial class AppDbContext : DbContext
{
    public virtual DbSet<Product> Products { get; set; }
    public virtual DbSet<Category> Categories { get; set; }

    public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Fluent API config generated from your DB
    }
}
```

---

## Notes on Scaffold Options

- `--schema` – Select specific schema
- `--table` – Scaffold only specific tables
- `--context` – Name your DbContext explicitly
- `--data-annotations` – Use attributes instead of Fluent API

Example:

```bash
dotnet ef dbcontext scaffold "..." Microsoft.EntityFrameworkCore.SqlServer --table Product --table Category --context AppDbContext --data-annotations -o Models
```

---

## EF Core Power-Up (Memory Tip)

> "Database First = Scaffold the structure, skip the scratch."

---

Absolutely, Rahman. Here's a clean and practical **folder structure** for an EF Core Code First project, especially if you're using a **console app** or a simple layered architecture.

---

## Basic EF Core Folder Structure

```
EfCoreDemo/
│
├── Models/
│   └── Product.cs
│
├── Data/
│   └── AppDbContext.cs
│
├── Migrations/
│   └── [auto-generated migration files]
│
├── Program.cs
├── EfCoreDemo.csproj
```

---

## Explanation

### `Models/`
- Contains your entity classes (e.g., `Product.cs`, `Category.cs`)
- Keeps models separate from logic for better organization

### `Data/`
- Contains `AppDbContext.cs`
- Could also include `DbInitializer.cs` or `SeedData.cs` later

### `Migrations/`
- Auto-generated by EF Core when you run:
  ```bash
  dotnet ef migrations add InitialCreate
  ```

### `Program.cs`
- Entry point of the app, where you may call methods to test EF Core interactions

---

## Example Files

### `Models/Product.cs`

```csharp
namespace EfCoreDemo.Models;

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public decimal Price { get; set; }
}
```

### `Data/AppDbContext.cs`

```csharp
using EfCoreDemo.Models;
using Microsoft.EntityFrameworkCore;

namespace EfCoreDemo.Data;

public class AppDbContext : DbContext
{
    public DbSet<Product> Products { get; set; }

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("Server=localhost;Database=EfCoreDemoDb;Trusted_Connection=True;");
    }
}
```

---
Perfect, Rahman. Let’s go deeper into the **Code First approach** and focus on **how to define models properly**, including:

- Setting primary keys
- Making columns nullable
- Customizing column names and types
- Adding constraints like `MaxLength`, `Required`, `DefaultValue`, etc.

---

## Writing Models in Code First (EF Core)

Let’s say we’re designing a `Product` entity.

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

public class Product
{
    [Key] // Primary Key
    public int Id { get; set; }

    [Required] // Not null
    [MaxLength(100)] // VARCHAR(100)
    public string Name { get; set; } = null!;

    [Column(TypeName = "decimal(10, 2)")] // SQL decimal with precision
    public decimal Price { get; set; }

    public int? Quantity { get; set; } // Nullable int

    [Required]
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

    [ForeignKey("Category")]
    public int CategoryId { get; set; }

    public Category Category { get; set; } = null!;
}
```

---

## Attribute-Based Annotations

Here’s a table of the most important ones:

| Annotation             | Purpose                                          |
|------------------------|--------------------------------------------------|
| `[Key]`                | Marks as primary key                             |
| `[Required]`           | Makes field non-nullable                         |
| `[MaxLength(50)]`      | Limits string length in DB                       |
| `[Column(TypeName = "...")]` | Set custom SQL type                     |
| `[ForeignKey("...")]`  | Specify FK relationship                          |
| `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]` | Auto-increment |

---

## Example: `Category` Entity

```csharp
public class Category
{
    [Key]
    public int Id { get; set; }

    [Required]
    [MaxLength(50)]
    public string Name { get; set; } = null!;

    public ICollection<Product> Products { get; set; } = new List<Product>();
}
```

---

## Fluent API (Alternative to Annotations)

In `AppDbContext.cs`:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Product>(entity =>
    {
        entity.HasKey(p => p.Id);
        entity.Property(p => p.Name)
              .HasMaxLength(100)
              .IsRequired();
        entity.Property(p => p.Price)
              .HasColumnType("decimal(10,2)");
        entity.Property(p => p.Quantity)
              .IsRequired(false); // Nullable
        entity.HasOne(p => p.Category)
              .WithMany(c => c.Products)
              .HasForeignKey(p => p.CategoryId);
    });
}
```

You can mix **data annotations** and **Fluent API**, but Fluent API overrides annotations.

---

## EF Core Power-Up (Memory Tip)

> "Annotations describe. Fluent API defines. Use one for quick, both for full control."

---

Love it, Rahman. Let's take a **realistic mini e-commerce schema** using Code First and cover every important variation in EF Core:

- Nullable & non-nullable fields
- Primary keys & composite keys
- Foreign keys
- Shadow properties
- Value defaults
- Data annotations vs Fluent API
- Relationships (One-to-Many, Many-to-Many)
- Special field types (DateTime, bool, decimal, enum, etc.)

---

## Scenario

We’ll build the following schema:

- `Customer` – can place many orders.
- `Order` – belongs to one customer, has many `OrderDetail`.
- `Product` – sold in `OrderDetail`.
- `OrderDetail` – bridge entity between `Order` and `Product` (many-to-many), includes `Quantity`, `UnitPrice`, and variation fields.

---

## Folder Structure

```
EfCoreDemo/
├── Models/
│   ├── Customer.cs
│   ├── Order.cs
│   ├── Product.cs
│   ├── OrderDetail.cs
├── Data/
│   └── AppDbContext.cs
```

---

## 1. `Customer.cs`

```csharp
using System.ComponentModel.DataAnnotations;

public class Customer
{
    [Key] // Primary Key
    public int CustomerId { get; set; }

    [Required] // Non-nullable in DB
    [MaxLength(100)]
    public string Name { get; set; } = null!;

    [MaxLength(255)]
    public string? Email { get; set; } // Nullable

    public DateTime CreatedAt { get; set; } = DateTime.UtcNow; // Default value

    // Navigation
    public ICollection<Order> Orders { get; set; } = new List<Order>();
}
```

---

## 2. `Order.cs`

```csharp
using System.ComponentModel.DataAnnotations.Schema;

public class Order
{
    public int OrderId { get; set; }

    public DateTime OrderDate { get; set; }

    public bool? IsGiftWrapped { get; set; } // Nullable boolean

    // Foreign Key & Navigation
    public int CustomerId { get; set; }
    public Customer Customer { get; set; } = null!;

    public ICollection<OrderDetail> OrderDetails { get; set; } = new List<OrderDetail>();
}
```

---

## 3. `Product.cs`

```csharp
public enum ProductStatus
{
    Active,
    Inactive,
    Archived
}

public class Product
{
    public int ProductId { get; set; }

    public string Name { get; set; } = null!;

    [Column(TypeName = "decimal(10, 2)")]
    public decimal Price { get; set; }

    public ProductStatus Status { get; set; } = ProductStatus.Active; // Enum

    public ICollection<OrderDetail> OrderDetails { get; set; } = new List<OrderDetail>();
}
```

---

## 4. `OrderDetail.cs` (Many-to-Many with Composite Key)

```csharp
public class OrderDetail
{
    // Composite Key
    public int OrderId { get; set; }
    public int ProductId { get; set; }

    public int Quantity { get; set; }

    [Column(TypeName = "decimal(10,2)")]
    public decimal UnitPrice { get; set; }

    public string? Size { get; set; } // Nullable string

    public string Color { get; set; } = "Default"; // Default value

    // Navigation
    public Order Order { get; set; } = null!;
    public Product Product { get; set; } = null!;
}
```

---

## 5. `AppDbContext.cs` with Fluent API

```csharp
using Microsoft.EntityFrameworkCore;

public class AppDbContext : DbContext
{
    public DbSet<Customer> Customers => Set<Customer>();
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<Product> Products => Set<Product>();
    public DbSet<OrderDetail> OrderDetails => Set<OrderDetail>();

    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        optionsBuilder.UseSqlServer("YourConnectionStringHere");
    }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Composite Key
        modelBuilder.Entity<OrderDetail>()
            .HasKey(od => new { od.OrderId, od.ProductId });

        // Shadow Property: added without defining in C# model
        modelBuilder.Entity<Product>()
            .Property<DateTime>("CreatedAt")
            .HasDefaultValueSql("GETUTCDATE()");

        // Configure relationships
        modelBuilder.Entity<Order>()
            .HasOne(o => o.Customer)
            .WithMany(c => c.Orders)
            .HasForeignKey(o => o.CustomerId);

        modelBuilder.Entity<OrderDetail>()
            .HasOne(od => od.Order)
            .WithMany(o => o.OrderDetails)
            .HasForeignKey(od => od.OrderId);

        modelBuilder.Entity<OrderDetail>()
            .HasOne(od => od.Product)
            .WithMany(p => p.OrderDetails)
            .HasForeignKey(od => od.ProductId);
    }
}
```

---

## What This Covers:

| Feature                     | Where Used                                     |
|----------------------------|------------------------------------------------|
| Primary Key                | `[Key]`, defaults like `ProductId`             |
| Composite Key              | `OrderDetail` → `HasKey(...)`                  |
| Nullable                   | `Email`, `IsGiftWrapped`, `Size`               |
| Non-Nullable               | `Name`, `CustomerId`, `Price`                  |
| Default Values             | `Color`, `CreatedAt`                           |
| Enum                       | `ProductStatus` in `Product`                   |
| Shadow Property            | `CreatedAt` on `Product` (not defined in model)|
| Decimal Type Mapping       | `Price`, `UnitPrice`                           |
| Relationships              | All navigation properties                      |

---

## EF Core Power-Up (Memory Tip)

> "Code First gives you full power: annotations to guide, Fluent API to command."

---
You're absolutely right to question that, Rahman — great eye! Let’s clarify and correct everything:

---

## 1. **ForeignKey Attributes** – When to Use and When Not

EF Core **infers foreign keys automatically** if naming conventions are followed:
- `CustomerId` + navigation property `Customer` → EF figures out the relationship.

However, **you *can* and sometimes *should*** use `[ForeignKey]` when:
- You want **explicit control**.
- Your foreign key property doesn’t match EF's naming convention.
- You have **multiple navigation properties** to the same entity.

### Example of Explicit ForeignKey

```csharp
public class Order
{
    public int OrderId { get; set; }

    [ForeignKey("Customer")]
    public int CustomerId { get; set; }

    public Customer Customer { get; set; } = null!;
}
```

But since we named it `CustomerId` and the navigation is `Customer`, EF Core can infer the relationship *without* needing `[ForeignKey]`.

So:
- ✅ It’s **optional** if you follow conventions.
- ✅ It’s **recommended** when conventions aren't followed or you want clarity.

---

## 2. **Navigation Property Defaults (`= new List<>();` vs `null`)**

This is an important stylistic and functional choice.

### `= new List<>()`
- This **avoids null reference exceptions** when accessing `.Add()`, `.Count`, etc.
- Safer for **collection navigations** like `Customer.Orders` or `Product.OrderDetails`.

```csharp
public ICollection<Order> Orders { get; set; } = new List<Order>(); // ✅ Safe
```

### `= null!`
- Used for **reference navigations** (`Customer`, `Product`, etc.)
- The `!` (null-forgiving) tells the compiler: "I’ll make sure this isn’t null at runtime."

```csharp
public Customer Customer { get; set; } = null!; // ✅ EF will populate this
```

If you use `null` without `!`, EF Core will still work, but the compiler will warn you.

---

## Final Corrections (Best Practice Style)

Here’s how it *should* look for best safety and clarity:

```csharp
public class Order
{
    public int OrderId { get; set; }

    [ForeignKey("Customer")] // Optional but explicit
    public int CustomerId { get; set; }

    public Customer Customer { get; set; } = null!;

    public ICollection<OrderDetail> OrderDetails { get; set; } = new List<OrderDetail>(); // ✅ prevents null refs
}
```

---

## Summary of Corrections

| Topic                 | Correction / Best Practice                         |
|----------------------|----------------------------------------------------|
| `[ForeignKey]`        | Optional if naming is standard, recommended if not |
| `= null!`             | ✅ Use for reference navigations (EF populates it) |
| `= new List<>()`      | ✅ Use for collection navigations (avoid nulls)     |

---


Sure, Rahman. Let’s break down the `DbContext` class in detail. It’s the **central bridge** between your C# models and the database in EF Core.

---

## What Is `DbContext`?

`DbContext` is a class provided by EF Core that:
- **Manages entity objects** during runtime.
- **Tracks changes** made to them.
- **Saves data** to the database.
- **Builds queries** against the database.

You define your own context by inheriting from `DbContext`.

---

## Structure of a Typical `DbContext` Class

```csharp
using Microsoft.EntityFrameworkCore;

public class AppDbContext : DbContext
{
    // 1. DbSet properties (tables)
    public DbSet<Customer> Customers => Set<Customer>();
    public DbSet<Order> Orders => Set<Order>();
    public DbSet<Product> Products => Set<Product>();
    public DbSet<OrderDetail> OrderDetails => Set<OrderDetail>();

    // 2. Constructor (usually inject options)
    public AppDbContext(DbContextOptions<AppDbContext> options)
        : base(options) {}

    // 3. OnConfiguring (for manual setup or console apps)
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.UseSqlServer("Server=localhost;Database=EfCoreDemoDb;Trusted_Connection=True;");
        }
    }

    // 4. OnModelCreating (Fluent API configuration)
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Composite key for OrderDetail
        modelBuilder.Entity<OrderDetail>()
            .HasKey(od => new { od.OrderId, od.ProductId });

        // Shadow property example
        modelBuilder.Entity<Product>()
            .Property<DateTime>("CreatedAt")
            .HasDefaultValueSql("GETUTCDATE()");
    }
}
```

---

### 1. **DbSet<T> Properties**

These represent **tables** in your database. Each `DbSet<T>` is a table for the entity `T`.

Example:
```csharp
public DbSet<Customer> Customers => Set<Customer>();
```
- This exposes a table called `Customers` in your database.
- Enables queries like `context.Customers.ToListAsync();`

---

### 2. **Constructor with `DbContextOptions`**

```csharp
public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) {}
```
This constructor allows dependency injection in ASP.NET Core so the context can be passed to controllers or services.

In a console app, if you're not using DI, you usually rely on `OnConfiguring` instead.

---

### 3. **OnConfiguring**

```csharp
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
```

Used to configure:
- The database provider (SQL Server, PostgreSQL, SQLite, etc.)
- Logging
- Connection strings (if not using appsettings.json)

In production ASP.NET apps, this is often handled externally via DI and appsettings, so this method may stay empty.

---

### 4. **OnModelCreating**

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
```

This is where you configure:
- Keys (composite, alternate)
- Relationships (One-to-Many, Many-to-Many)
- Default values
- Indexes
- Shadow properties
- Table/column names

You use the **Fluent API** here to override or extend behavior defined with data annotations.

Example:
```csharp
modelBuilder.Entity<Product>()
    .Property(p => p.Name)
    .IsRequired()
    .HasMaxLength(200);
```

---

## Behind the Scenes

When you do:

```csharp
var products = await context.Products.ToListAsync();
```

EF Core:
1. Builds a SQL query based on `Product` model and its mappings.
2. Sends it to the database.
3. Maps the result to C# `Product` objects.
4. Tracks those objects so future changes can be saved.

---

## Summary of Responsibilities

| Method                    | Purpose                                          |
|---------------------------|--------------------------------------------------|
| `DbSet<T>`                | Exposes tables/entities                          |
| `OnConfiguring`           | Sets up provider and connection                  |
| `OnModelCreating`         | Fluent API overrides and custom mappings         |
| Constructor               | Accepts configuration (often used with DI)       |

---

Great timing, Rahman. Let’s go through the **complete EF Core migration workflow** using the Code First approach. This process is how EF Core **translates your C# models into real SQL tables and applies changes to the database schema** over time.

---

## What Are Migrations?

Migrations:
- Track changes in your models over time.
- Automatically generate SQL scripts.
- Apply changes to the database via commands.

They are stored as **C# files** inside a `Migrations/` folder in your project.

---

## Step-by-Step: Migration Workflow

### Step 1: Add the EF Core Tools (If Not Done Yet)

```bash
dotnet add package Microsoft.EntityFrameworkCore.Tools
```

---

### Step 2: Create the First Migration

```bash
dotnet ef migrations add InitialCreate
```

- This generates a folder named `Migrations/`.
- It includes:
  - A migration file with `Up()` and `Down()` methods.
  - A `ModelSnapshot.cs` file for comparing future model changes.

**Example file generated:**
```
Migrations/
├── 20250414121234_InitialCreate.cs
├── AppDbContextModelSnapshot.cs
```

### `Up()` method

```csharp
protected override void Up(MigrationBuilder migrationBuilder)
{
    migrationBuilder.CreateTable(
        name: "Customers",
        columns: table => new
        {
            CustomerId = table.Column<int>(nullable: false)
                .Annotation("SqlServer:Identity", "1, 1"),
            Name = table.Column<string>(maxLength: 100, nullable: false),
            Email = table.Column<string>(maxLength: 255, nullable: true),
            CreatedAt = table.Column<DateTime>(nullable: false)
        },
        constraints: table =>
        {
            table.PrimaryKey("PK_Customers", x => x.CustomerId);
        });
    // Same goes for other entities
}
```

### Step 3: Apply the Migration to the Database

```bash
dotnet ef database update
```

This command:
- Executes the `Up()` method of the latest migration.
- Creates all the tables and relationships in your actual database.

---

## Common Migration Commands

| Command | What it does |
|--------|--------------|
| `dotnet ef migrations add <Name>` | Creates a new migration file based on model changes |
| `dotnet ef database update` | Applies all pending migrations to the database |
| `dotnet ef migrations remove` | Removes the last migration (if not yet applied) |
| `dotnet ef database update <MigrationName>` | Rollbacks or updates to a specific migration |
| `dotnet ef database drop` | Deletes the database (use with caution) |

---

## Example: Modifying a Model and Creating a New Migration

Suppose you add a `PhoneNumber` to the `Customer` model:

```csharp
public string? PhoneNumber { get; set; }
```

Now generate a new migration:

```bash
dotnet ef migrations add AddCustomerPhoneNumber
dotnet ef database update
```

EF will:
- Compare current models with the `ModelSnapshot`
- Generate a migration to **alter the table**
- Apply that change to the database

---

## EF Core Power-Up (Memory Tip)

> “Migrations = Version control for your database. Models drive them. EF syncs them.”

---
Let's now add data (also called **seeding**) into your tables using EF Core.

There are **two main approaches**:
1. **Manual seeding** – insert data via code using `DbContext`.
2. **EF Core automatic seeding** – using `HasData()` in `OnModelCreating()`.

I'll show you both, starting with the **manual approach**, then moving to **automatic `HasData` seeding**.

---

## 1. Manual Data Insertion (for development or tests)

This is ideal for scripts or initial app setup.

```csharp
using var context = new AppDbContext();

// Add customers
var customer1 = new Customer { Name = "Rahman", Email = "rahman@example.com" };
var customer2 = new Customer { Name = "Jane Doe" };

context.Customers.AddRange(customer1, customer2);

// Add products
var product1 = new Product { Name = "Laptop", Price = 1500 };
var product2 = new Product { Name = "Mouse", Price = 25.99M };

context.Products.AddRange(product1, product2);

// Save to DB
await context.SaveChangesAsync();

// Add an order
var order = new Order
{
    CustomerId = customer1.CustomerId,
    OrderDate = DateTime.UtcNow,
    IsGiftWrapped = false
};
context.Orders.Add(order);
await context.SaveChangesAsync();

// Add order details
var detail1 = new OrderDetail
{
    OrderId = order.OrderId,
    ProductId = product1.ProductId,
    Quantity = 1,
    UnitPrice = product1.Price,
    Size = "15 inch",
    Color = "Gray"
};

var detail2 = new OrderDetail
{
    OrderId = order.OrderId,
    ProductId = product2.ProductId,
    Quantity = 2,
    UnitPrice = product2.Price,
    Color = "Black"
};

context.OrderDetails.AddRange(detail1, detail2);
await context.SaveChangesAsync();
```

Use this approach when:
- Testing
- Initializing demo data
- Running one-time setup

---

## 2. Automatic Seeding Using `HasData()`

This adds data automatically when migrations are applied.

In `AppDbContext.cs`, inside `OnModelCreating()`:

```csharp
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Customer>().HasData(
        new Customer { CustomerId = 1, Name = "Rahman", Email = "rahman@example.com", CreatedAt = DateTime.UtcNow },
        new Customer { CustomerId = 2, Name = "Jane Doe", Email = "jane@example.com", CreatedAt = DateTime.UtcNow }
    );

    modelBuilder.Entity<Product>().HasData(
        new Product { ProductId = 1, Name = "Laptop", Price = 1500, Status = ProductStatus.Active },
        new Product { ProductId = 2, Name = "Mouse", Price = 25.99M, Status = ProductStatus.Active }
    );
}
```

Then:

```bash
dotnet ef migrations add SeedInitialData
dotnet ef database update
```

EF Core will insert this data during the migration update.

**Note:** `HasData()` requires hardcoded primary key values and full property initialization, including non-nullable/default fields.

---

## Best Practice Summary

| Approach         | When to Use                             |
|------------------|------------------------------------------|
| `DbContext` insert | Development/test/data entry logic       |
| `HasData()`        | Stable initial data during migration    |

---
Great objective, Rahman. Let's go all in. We’ll read data from your **Customer**, **Order**, **Product**, and **OrderDetail** tables using:

- **LINQ Method Chaining (Lambda syntax)**
- **LINQ Query Syntax (SQL-like style)**

We'll cover all common types of queries:

- Basic SELECTs
- Filtering
- Ordering
- Projections
- Joins (inner, left)
- Grouping
- Aggregates
- Includes (eager loading)
- Anonymous types
- Navigation property usage

Each section includes both LINQ styles and a sample response.

---

### 1. Get All Customers

#### Method Syntax

```csharp
var customers = await context.Customers.ToListAsync();
```

#### Query Syntax

```csharp
var customers = await (from c in context.Customers
                       select c).ToListAsync();
```

#### Sample Response

```json
[
  { "CustomerId": 1, "Name": "Rahman", "Email": "rahman@example.com" },
  { "CustomerId": 2, "Name": "Jane Doe", "Email": "jane@example.com" }
]
```

---

### 2. Filter Products by Price > 100

#### Method Syntax

```csharp
var expensive = await context.Products
    .Where(p => p.Price > 100)
    .ToListAsync();
```

#### Query Syntax

```csharp
var expensive = await (from p in context.Products
                       where p.Price > 100
                       select p).ToListAsync();
```

#### Sample Response

```json
[
  { "ProductId": 1, "Name": "Laptop", "Price": 1500 }
]
```

---

### 3. Order Customers Alphabetically by Name

```csharp
var sorted = await context.Customers
    .OrderBy(c => c.Name)
    .ToListAsync();
```

```csharp
var sorted = await (from c in context.Customers
                    orderby c.Name
                    select c).ToListAsync();
```

---

### 4. Select Specific Fields Only

```csharp
var names = await context.Customers
    .Select(c => new { c.Name, c.Email })
    .ToListAsync();
```

```csharp
var names = await (from c in context.Customers
                   select new { c.Name, c.Email }).ToListAsync();
```

#### Sample Response

```json
[
  { "Name": "Rahman", "Email": "rahman@example.com" },
  { "Name": "Jane Doe", "Email": "jane@example.com" }
]
```

---

### 5. Include Navigation Properties (Eager Load Orders)

```csharp
var customersWithOrders = await context.Customers
    .Include(c => c.Orders)
    .ToListAsync();
```

#### Sample Response

```json
[
  {
    "CustomerId": 1,
    "Name": "Rahman",
    "Orders": [
      { "OrderId": 1, "OrderDate": "2025-04-14" }
    ]
  }
]
```

---

### 6. Inner Join: Order with Customer Info

```csharp
var orders = await context.Orders
    .Join(context.Customers,
          o => o.CustomerId,
          c => c.CustomerId,
          (o, c) => new { o.OrderId, c.Name, o.OrderDate })
    .ToListAsync();
```

```csharp
var orders = await (from o in context.Orders
                    join c in context.Customers on o.CustomerId equals c.CustomerId
                    select new { o.OrderId, c.Name, o.OrderDate }).ToListAsync();
```

---

### 7. Left Join: All Customers, Even Those Without Orders

```csharp
var result = await (from c in context.Customers
                    join o in context.Orders on c.CustomerId equals o.CustomerId into orders
                    from o in orders.DefaultIfEmpty()
                    select new { c.Name, OrderId = o != null ? o.OrderId : (int?)null })
                    .ToListAsync();
```

---

### 8. Group Orders by Customer

```csharp
var grouped = await context.Orders
    .GroupBy(o => o.CustomerId)
    .Select(g => new
    {
        CustomerId = g.Key,
        TotalOrders = g.Count()
    }).ToListAsync();
```

```csharp
var grouped = await (from o in context.Orders
                     group o by o.CustomerId into g
                     select new { CustomerId = g.Key, TotalOrders = g.Count() })
                    .ToListAsync();
```

---

### 9. Aggregate Total Sales

```csharp
var totalSales = await context.OrderDetails
    .SumAsync(od => od.UnitPrice * od.Quantity);
```

---

### 10. Get Latest Order Per Customer

```csharp
var latestOrders = await context.Orders
    .GroupBy(o => o.CustomerId)
    .Select(g => g.OrderByDescending(o => o.OrderDate).First())
    .ToListAsync();
```

---

### 11. Filter with Any() – Customers Who Placed Orders

```csharp
var withOrders = await context.Customers
    .Where(c => c.Orders.Any())
    .ToListAsync();
```

---

### 12. Flatten Navigation: Get All Order Details with Product and Order Info

```csharp
var detailed = await context.OrderDetails
    .Include(od => od.Order)
    .Include(od => od.Product)
    .Select(od => new
    {
        od.OrderId,
        od.ProductId,
        ProductName = od.Product.Name,
        od.Quantity,
        od.UnitPrice,
        od.Color
    }).ToListAsync();
```

---
Great. Let's now extend this by implementing full **CRUD operations** using EF Core with:

- Filtering with `enum`
- Paging using `Skip()` and `Take()`
- Basic keyword search
- Full **Create**, **Read**, **Update**, **Delete** examples
- Use of DTOs (optional but best practice)

Let’s focus on `Product` as the base entity, and use `ProductStatus` enum.

---

## 1. Filtering by Enum

```csharp
var activeProducts = await context.Products
    .Where(p => p.Status == ProductStatus.Active)
    .ToListAsync();
```

#### Sample Enum

```csharp
public enum ProductStatus
{
    Active,
    Inactive,
    Archived
}
```

---

## 2. Paging (`Skip` + `Take`)

```csharp
int pageNumber = 2;
int pageSize = 10;

var pagedProducts = await context.Products
    .OrderBy(p => p.ProductId)
    .Skip((pageNumber - 1) * pageSize)
    .Take(pageSize)
    .ToListAsync();
```

---

## 3. Simple Search by Keyword in Name

```csharp
string keyword = "laptop";

var result = await context.Products
    .Where(p => p.Name.Contains(keyword))
    .ToListAsync();
```

---

## 4. Full CRUD for `Product`

### Create Product

```csharp
var product = new Product
{
    Name = "Tablet",
    Price = 450.00m,
    Status = ProductStatus.Active
};

context.Products.Add(product);
await context.SaveChangesAsync();
```

---

### Read Product by ID

```csharp
int id = 1;
var product = await context.Products.FindAsync(id);
```

---

### Update Product

```csharp
var product = await context.Products.FindAsync(1);
if (product != null)
{
    product.Price = 499.99m;
    product.Status = ProductStatus.Inactive;
    await context.SaveChangesAsync();
}
```

---

### Delete Product

```csharp
var product = await context.Products.FindAsync(1);
if (product != null)
{
    context.Products.Remove(product);
    await context.SaveChangesAsync();
}
```

---

## 5. Bonus: Project into a DTO

```csharp
var productDtos = await context.Products
    .Select(p => new
    {
        p.Name,
        p.Price,
        Status = p.Status.ToString()
    }).ToListAsync();
```

---

## EF Core Power-Up (Memory Tip)

> "Use Skip + Take for paging, Enums for filtering, and LINQ projections for shaping your data into what your UI really needs."

---
Alright Rahman, let’s now go through the **Database First (Scaffold-DbContext)** process using the existing database you’ve already built with your `Customer`, `Order`, `Product`, and `OrderDetail` tables.

This process is the reverse of Code First. Instead of building the database from your C# models, you **generate the models and DbContext from an existing database schema**.

---

## Step-by-Step: Scaffold from Existing Database

### 1. Ensure EF Core Tools are Installed

```bash
dotnet add package Microsoft.EntityFrameworkCore.SqlServer
dotnet add package Microsoft.EntityFrameworkCore.Tools
```

---

### 2. Use `Scaffold-DbContext` Command

```bash
dotnet ef dbcontext scaffold "Server=localhost;Database=EfCoreDemoDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -o Models -c AppDbContext
```

Explanation:

| Parameter                | Description                                          |
|--------------------------|------------------------------------------------------|
| Connection string        | Points to your **existing DB**                       |
| Provider                 | SQL Server provider                                 |
| `-o Models`              | Output folder for generated entity classes          |
| `-c AppDbContext`        | Name of the generated DbContext class               |

---

### 3. Resulting Folder Structure

```
EfCoreScaffoldDemo/
├── Models/
│   ├── Customer.cs
│   ├── Order.cs
│   ├── Product.cs
│   ├── OrderDetail.cs
├── AppDbContext.cs
├── Program.cs
```

---

## What Do These Files Look Like?

### `Customer.cs` (Generated)

```csharp
public partial class Customer
{
    public int CustomerId { get; set; }
    public string Name { get; set; } = null!;
    public string? Email { get; set; }
    public DateTime CreatedAt { get; set; }

    public virtual ICollection<Order> Orders { get; set; } = new List<Order>();
}
```

---

### `AppDbContext.cs` (Generated)

```csharp
public partial class AppDbContext : DbContext
{
    public AppDbContext() {}

    public AppDbContext(DbContextOptions<AppDbContext> options)
        : base(options) {}

    public virtual DbSet<Customer> Customers { get; set; }
    public virtual DbSet<Order> Orders { get; set; }
    public virtual DbSet<Product> Products { get; set; }
    public virtual DbSet<OrderDetail> OrderDetails { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.Entity<OrderDetail>(entity =>
        {
            entity.HasKey(e => new { e.OrderId, e.ProductId });

            entity.HasOne(d => d.Order)
                .WithMany(p => p.OrderDetails)
                .HasForeignKey(d => d.OrderId);

            entity.HasOne(d => d.Product)
                .WithMany(p => p.OrderDetails)
                .HasForeignKey(d => d.ProductId);
        });

        // Fluent API mapping of other entities...
    }
}
```

---

## Benefits of Database First

- Ideal for legacy or pre-existing databases
- Saves time when you don’t control the schema
- Keeps models in sync with DB if schema changes

---

## Extra Options (Optional)

- Scaffold specific tables:

```bash
--table Customers --table Orders
```

- Use Data Annotations instead of Fluent API:

```bash
--data-annotations
```

- Re-scaffold when DB updates (overwrite carefully):

```bash
--force
```

---

## EF Core Power-Up (Memory Tip)

> “Code First drives the DB. DB First follows it. Scaffold when DB already exists.”

---
Great question, Rahman. When you're using **Database First** and the **database schema changes**, you have two main options depending on how you want to keep your application models up-to-date.

---

## When the DB Schema Changes (Database First)

### ✅ Recommended: Re-Scaffold the DbContext and Models

You use the `Scaffold-DbContext` command **again** to regenerate the updated models.

### Step-by-Step:

```bash
dotnet ef dbcontext scaffold "Server=localhost;Database=EfCoreDemoDb;Trusted_Connection=True;" Microsoft.EntityFrameworkCore.SqlServer -o Models -c AppDbContext --force
```

### Additions:

| Option        | Description                                  |
|---------------|----------------------------------------------|
| `--force`     | Overwrites existing models and context       |
| `--table`     | Specify only the tables that changed         |
| `--no-onconfiguring` | Skip generating OnConfiguring method   |

---

### Example 1: A New Column Was Added to the `Product` Table

If the DB now includes a `Description` column:

#### What to Do:
- Run the scaffold command again with `--force`.
- The generated `Product.cs` will now include:

```csharp
public string? Description { get; set; }
```

---

### Example 2: A New Table `Supplier` Was Added

#### What to Do:
You can scaffold just that table:

```bash
dotnet ef dbcontext scaffold "..." Microsoft.EntityFrameworkCore.SqlServer -o Models -c AppDbContext --table Supplier
```

This adds `Supplier.cs` and its mapping without affecting other models.

---

## Alternative: Manually Modify Model Classes

If you’re using the scaffolded models as-is, you *can* manually edit them.

But:
- You **lose the ability to safely re-scaffold** without wiping changes.
- You risk **model mismatches** if the schema evolves.

So:
- **Use manual edits only** if the schema won't change often.
- Otherwise, separate your **custom logic into partial classes**.

---

## Best Practice for Changes

- Use **partial classes** for custom logic.
- Keep scaffolded models auto-generated only.
- Regenerate the scaffold when the schema changes.
- Consider **mapping to your own DTOs/viewmodels** instead of using entities directly.

---

## Summary

| Scenario                          | What You Should Do                         |
|-----------------------------------|---------------------------------------------|
| Column Added/Removed              | Re-scaffold using `--force`                 |
| Table Added                       | Scaffold specific table with `--table`      |
| Relationships Updated             | Re-scaffold affected models                 |
| Models Customized Manually        | Use partial classes to avoid loss           |

---
Sure Rahman, let's go through a practical example of using **partial classes** in EF Core to **protect your custom logic** when using the **Database First** approach.

This is **essential** because when you re-scaffold, EF Core **overwrites** the generated files (like `Product.cs`). But if you separate your logic into a `partial class`, it won't get touched.

---

## Scenario: Scaffolded `Product.cs`

Assume this file is generated by EF Core in the `Models` folder:

```csharp
// Models/Product.cs (auto-generated)

public partial class Product
{
    public int ProductId { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string? Description { get; set; }

    public virtual ICollection<OrderDetail> OrderDetails { get; set; } = new List<OrderDetail>();
}
```

---

## Step 1: Create a `Product.Custom.cs` File in the Same Namespace

This file **won’t be overwritten** when you re-scaffold.

```csharp
// Models/Product.Custom.cs

public partial class Product
{
    public string GetFormattedPrice()
    {
        return $"${Price:N2}";
    }

    public bool IsHighValueProduct => Price > 1000;
}
```

You can put this in the same `Models` folder or a different one. What matters is that:
- It's marked as `partial`
- The class name matches
- It's in the same namespace

---

## Step 2: Use the Custom Logic

```csharp
using var context = new AppDbContext();

var product = await context.Products.FirstAsync();

Console.WriteLine(product.GetFormattedPrice());      // $1500.00
Console.WriteLine(product.IsHighValueProduct);       // True
```

---

## Summary of Benefits

| Feature                  | Benefit                                     |
|--------------------------|---------------------------------------------|
| `partial class`          | Split the class into multiple files         |
| Keeps logic separate     | Safe from scaffold overwrites               |
| Organizes functionality  | Model structure in one, custom logic in another |

---
Let's walk through how to build a full **ASP.NET Core Web API** using:

-   **EF Core (Database First or Code First)**

-   **Repository Pattern**

-   **Configuration via `appsettings.json`**

-   Clean **Project Structure**

-   Full **CRUD controllers** for `Customer`, `Product`, `Order`, `OrderDetail`

* * * * *

✅ Final Project Structure
-------------------------

```
ECommerceApi/
├── Controllers/
│   ├── CustomersController.cs
│   ├── ProductsController.cs
│   ├── OrdersController.cs
│   └── OrderDetailsController.cs
│
├── Data/
│   ├── AppDbContext.cs
│   ├── IRepository.cs
│   ├── Repository.cs
│   ├── IProductRepository.cs
│   └── ProductRepository.cs
│
├── Models/
│   ├── Customer.cs
│   ├── Product.cs
│   ├── Order.cs
│   └── OrderDetail.cs
│
├── appsettings.json
├── Program.cs
├── ECommerceApi.csproj

```

* * * * *

1\. Configure `appsettings.json`
--------------------------------

```
{
  "ConnectionStrings": {
    "DefaultConnection": "Server=localhost;Database=EfCoreDemoDb;Trusted_Connection=True;"
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information"
    }
  },
  "AllowedHosts": "*"
}

```

* * * * *

2\. Register `DbContext` in `Program.cs`
----------------------------------------

```
builder.Services.AddDbContext<AppDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
builder.Services.AddScoped<IProductRepository, ProductRepository>();

builder.Services.AddControllers();

```

* * * * *
Great, Rahman. Let’s create **repository interfaces and implementations** for all four entities:

- `Customer`
- `Product`
- `Order`
- `OrderDetail`

Each will follow the **Repository Pattern** and plug into your **generic base repository**.

---

## Folder Structure: `/Data`

```
Data/
├── IRepository.cs
├── Repository.cs
├── IProductRepository.cs
├── ProductRepository.cs
├── ICustomerRepository.cs
├── CustomerRepository.cs
├── IOrderRepository.cs
├── OrderRepository.cs
├── IOrderDetailRepository.cs
├── OrderDetailRepository.cs
```

---

## 1. Shared Generic Interface: `IRepository<T>`

```csharp
public interface IRepository<T> where T : class
{
    Task<IEnumerable<T>> GetAllAsync();
    Task<T?> GetByIdAsync(int id);
    Task AddAsync(T entity);
    void Update(T entity);
    void Delete(T entity);
    Task SaveAsync();
}
```

---

## 2. Shared Generic Implementation: `Repository<T>`

```csharp
public class Repository<T> : IRepository<T> where T : class
{
    protected readonly AppDbContext _context;
    protected readonly DbSet<T> _dbSet;

    public Repository(AppDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }

    public async Task<IEnumerable<T>> GetAllAsync() => await _dbSet.ToListAsync();
    public async Task<T?> GetByIdAsync(int id) => await _dbSet.FindAsync(id);
    public async Task AddAsync(T entity) => await _dbSet.AddAsync(entity);
    public void Update(T entity) => _dbSet.Update(entity);
    public void Delete(T entity) => _dbSet.Remove(entity);
    public async Task SaveAsync() => await _context.SaveChangesAsync();
}
```

---

## 3. Product Repository

### `IProductRepository.cs`

```csharp
public interface IProductRepository : IRepository<Product>
{
    Task<IEnumerable<Product>> GetActiveProductsAsync();
}
```

### `ProductRepository.cs`

```csharp
public class ProductRepository : Repository<Product>, IProductRepository
{
    public ProductRepository(AppDbContext context) : base(context) { }

    public async Task<IEnumerable<Product>> GetActiveProductsAsync()
    {
        return await _dbSet.Where(p => p.Status == ProductStatus.Active).ToListAsync();
    }
}
```

---

## 4. Customer Repository

### `ICustomerRepository.cs`

```csharp
public interface ICustomerRepository : IRepository<Customer>
{
    Task<IEnumerable<Customer>> GetWithOrdersAsync();
}
```

### `CustomerRepository.cs`

```csharp
public class CustomerRepository : Repository<Customer>, ICustomerRepository
{
    public CustomerRepository(AppDbContext context) : base(context) { }

    public async Task<IEnumerable<Customer>> GetWithOrdersAsync()
    {
        return await _dbSet.Include(c => c.Orders).ToListAsync();
    }
}
```

---

## 5. Order Repository

### `IOrderRepository.cs`

```csharp
public interface IOrderRepository : IRepository<Order>
{
    Task<IEnumerable<Order>> GetWithDetailsAsync();
}
```

### `OrderRepository.cs`

```csharp
public class OrderRepository : Repository<Order>, IOrderRepository
{
    public OrderRepository(AppDbContext context) : base(context) { }

    public async Task<IEnumerable<Order>> GetWithDetailsAsync()
    {
        return await _dbSet
            .Include(o => o.OrderDetails)
            .ThenInclude(od => od.Product)
            .ToListAsync();
    }
}
```

---

## 6. OrderDetail Repository

### `IOrderDetailRepository.cs`

```csharp
public interface IOrderDetailRepository : IRepository<OrderDetail>
{
    Task<IEnumerable<OrderDetail>> GetByOrderIdAsync(int orderId);
}
```

### `OrderDetailRepository.cs`

```csharp
public class OrderDetailRepository : Repository<OrderDetail>, IOrderDetailRepository
{
    public OrderDetailRepository(AppDbContext context) : base(context) { }

    public async Task<IEnumerable<OrderDetail>> GetByOrderIdAsync(int orderId)
    {
        return await _dbSet
            .Where(od => od.OrderId == orderId)
            .Include(od => od.Product)
            .ToListAsync();
    }
}
```

---

## 7. Register Repositories in `Program.cs`

```csharp
builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
builder.Services.AddScoped<IProductRepository, ProductRepository>();
builder.Services.AddScoped<ICustomerRepository, CustomerRepository>();
builder.Services.AddScoped<IOrderRepository, OrderRepository>();
builder.Services.AddScoped<IOrderDetailRepository, OrderDetailRepository>();
```

---

Do you want me to scaffold the CRUD **controllers** for each of these next, or help you wire up some **DTOs and mapping logic** for cleaner separation?


Perfect, Rahman. Let’s now scaffold **CRUD controllers** for:

- `Customer`
- `Product`
- `Order`
- `OrderDetail`

Each controller will:
- Use its respective **repository interface**
- Provide **RESTful endpoints**
- Follow **async best practices**
- Return proper HTTP status codes

---

## Folder: `/Controllers`

```
Controllers/
├── CustomersController.cs
├── ProductsController.cs
├── OrdersController.cs
└── OrderDetailsController.cs
```

---

### 1. `CustomersController.cs`

```csharp
[Route("api/[controller]")]
[ApiController]
public class CustomersController : ControllerBase
{
    private readonly ICustomerRepository _repo;

    public CustomersController(ICustomerRepository repo)
    {
        _repo = repo;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll() => Ok(await _repo.GetAllAsync());

    [HttpGet("{id}")]
    public async Task<IActionResult> Get(int id)
    {
        var customer = await _repo.GetByIdAsync(id);
        return customer == null ? NotFound() : Ok(customer);
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] Customer customer)
    {
        await _repo.AddAsync(customer);
        await _repo.SaveAsync();
        return CreatedAtAction(nameof(Get), new { id = customer.CustomerId }, customer);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, [FromBody] Customer update)
    {
        var existing = await _repo.GetByIdAsync(id);
        if (existing == null) return NotFound();

        existing.Name = update.Name;
        existing.Email = update.Email;

        _repo.Update(existing);
        await _repo.SaveAsync();

        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id)
    {
        var customer = await _repo.GetByIdAsync(id);
        if (customer == null) return NotFound();

        _repo.Delete(customer);
        await _repo.SaveAsync();
        return NoContent();
    }
}
```

---

### 2. `ProductsController.cs`

```csharp
[Route("api/[controller]")]
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repo;

    public ProductsController(IProductRepository repo)
    {
        _repo = repo;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll() => Ok(await _repo.GetAllAsync());

    [HttpGet("active")]
    public async Task<IActionResult> GetActive() => Ok(await _repo.GetActiveProductsAsync());

    [HttpGet("{id}")]
    public async Task<IActionResult> Get(int id)
    {
        var product = await _repo.GetByIdAsync(id);
        return product == null ? NotFound() : Ok(product);
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] Product product)
    {
        await _repo.AddAsync(product);
        await _repo.SaveAsync();
        return CreatedAtAction(nameof(Get), new { id = product.ProductId }, product);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, [FromBody] Product update)
    {
        var existing = await _repo.GetByIdAsync(id);
        if (existing == null) return NotFound();

        existing.Name = update.Name;
        existing.Price = update.Price;
        existing.Status = update.Status;

        _repo.Update(existing);
        await _repo.SaveAsync();

        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id)
    {
        var product = await _repo.GetByIdAsync(id);
        if (product == null) return NotFound();

        _repo.Delete(product);
        await _repo.SaveAsync();
        return NoContent();
    }
}
```

---

### 3. `OrdersController.cs`

```csharp
[Route("api/[controller]")]
[ApiController]
public class OrdersController : ControllerBase
{
    private readonly IOrderRepository _repo;

    public OrdersController(IOrderRepository repo)
    {
        _repo = repo;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll() => Ok(await _repo.GetAllAsync());

    [HttpGet("{id}")]
    public async Task<IActionResult> Get(int id)
    {
        var order = await _repo.GetByIdAsync(id);
        return order == null ? NotFound() : Ok(order);
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] Order order)
    {
        await _repo.AddAsync(order);
        await _repo.SaveAsync();
        return CreatedAtAction(nameof(Get), new { id = order.OrderId }, order);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, [FromBody] Order update)
    {
        var existing = await _repo.GetByIdAsync(id);
        if (existing == null) return NotFound();

        existing.OrderDate = update.OrderDate;
        existing.IsGiftWrapped = update.IsGiftWrapped;

        _repo.Update(existing);
        await _repo.SaveAsync();

        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> Delete(int id)
    {
        var order = await _repo.GetByIdAsync(id);
        if (order == null) return NotFound();

        _repo.Delete(order);
        await _repo.SaveAsync();
        return NoContent();
    }
}
```

---

### 4. `OrderDetailsController.cs`

```csharp
[Route("api/[controller]")]
[ApiController]
public class OrderDetailsController : ControllerBase
{
    private readonly IOrderDetailRepository _repo;

    public OrderDetailsController(IOrderDetailRepository repo)
    {
        _repo = repo;
    }

    [HttpGet("order/{orderId}")]
    public async Task<IActionResult> GetByOrder(int orderId)
    {
        var details = await _repo.GetByOrderIdAsync(orderId);
        return Ok(details);
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] OrderDetail detail)
    {
        await _repo.AddAsync(detail);
        await _repo.SaveAsync();
        return Ok(detail);
    }

    [HttpPut]
    public async Task<IActionResult> Update([FromBody] OrderDetail update)
    {
        var existing = await _repo.GetByIdAsync(update.OrderId);
        if (existing == null) return NotFound();

        existing.Quantity = update.Quantity;
        existing.UnitPrice = update.UnitPrice;
        existing.Size = update.Size;
        existing.Color = update.Color;

        _repo.Update(existing);
        await _repo.SaveAsync();

        return NoContent();
    }

    [HttpDelete("{orderId}/{productId}")]
    public async Task<IActionResult> Delete(int orderId, int productId)
    {
        var detail = await _repo.GetByOrderIdAsync(orderId);
        var item = detail.FirstOrDefault(d => d.ProductId == productId);
        if (item == null) return NotFound();

        _repo.Delete(item);
        await _repo.SaveAsync();
        return NoContent();
    }
}
```

---

## Optional Next Steps

1. **Enable Swagger UI**

```bash
dotnet add package Swashbuckle.AspNetCore
```

Then in `Program.cs`:

```csharp
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

app.UseSwagger();
app.UseSwaggerUI();
```

2. **DTO Mapping with AutoMapper**
3. **Validation with FluentValidation**
4. **Add Unit Tests with InMemory DbContext**

---

Would you like to add Swagger next for interactive documentation, or move into DTO and validation patterns to clean up the API payloads?

Awesome, Rahman. Let's now implement **DTOs (Data Transfer Objects)** and use **AutoMapper** to clean up the API responses and input models. This is a major best practice for:

- Avoiding overexposing your EF Core entities
- Keeping input/output contracts clean and versionable
- Reducing model binding and validation issues

---

## What We'll Do

1. Add DTO classes for `Product` (you can repeat for others)
2. Install and configure AutoMapper
3. Use DTOs in the `ProductsController`
4. Apply mappings automatically with AutoMapper

---

## 1. Create DTO Classes

### Folder Structure

```
ECommerceApi/
├── Dtos/
│   ├── ProductDto.cs
│   ├── ProductCreateDto.cs
│   └── ProductUpdateDto.cs
```

### `ProductDto.cs` (for output)

```csharp
public class ProductDto
{
    public int ProductId { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string Status { get; set; } = "Active";
}
```

### `ProductCreateDto.cs` (for POST)

```csharp
public class ProductCreateDto
{
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
}
```

### `ProductUpdateDto.cs` (for PUT)

```csharp
public class ProductUpdateDto
{
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string Status { get; set; } = "Active";
}
```

---

## 2. Install AutoMapper

```bash
dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
```

---

## 3. Create AutoMapper Profile

Create file: `MappingProfiles/ProductProfile.cs`

```csharp
using AutoMapper;

public class ProductProfile : Profile
{
    public ProductProfile()
    {
        CreateMap<Product, ProductDto>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

        CreateMap<ProductCreateDto, Product>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => ProductStatus.Active));

        CreateMap<ProductUpdateDto, Product>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => Enum.Parse<ProductStatus>(src.Status)));
    }
}
```

---

## 4. Register AutoMapper in `Program.cs`

```csharp
builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
```

---

## 5. Update `ProductsController` to Use DTOs

```csharp
[Route("api/[controller]")]
[ApiController]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repo;
    private readonly IMapper _mapper;

    public ProductsController(IProductRepository repo, IMapper mapper)
    {
        _repo = repo;
        _mapper = mapper;
    }

    [HttpGet]
    public async Task<IActionResult> GetAll()
    {
        var products = await _repo.GetAllAsync();
        var productDtos = _mapper.Map<IEnumerable<ProductDto>>(products);
        return Ok(productDtos);
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> Get(int id)
    {
        var product = await _repo.GetByIdAsync(id);
        if (product == null) return NotFound();

        return Ok(_mapper.Map<ProductDto>(product));
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] ProductCreateDto dto)
    {
        var product = _mapper.Map<Product>(dto);
        await _repo.AddAsync(product);
        await _repo.SaveAsync();

        var result = _mapper.Map<ProductDto>(product);
        return CreatedAtAction(nameof(Get), new { id = result.ProductId }, result);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, [FromBody] ProductUpdateDto dto)
    {
        var product = await _repo.GetByIdAsync(id);
        if (product == null) return NotFound();

        _mapper.Map(dto, product);
        _repo.Update(product);
        await _repo.SaveAsync();

        return NoContent();
    }
}
```

---

## Benefits of Using DTOs with AutoMapper

| Benefit                        | Why It Matters                                 |
|-------------------------------|-------------------------------------------------|
| Decouples API from DB         | Avoids exposing full entity model              |
| Easier validation             | DTOs act as input contracts                    |
| Flexible mapping              | AutoMapper handles transformations cleanly     |
| Smaller payloads              | Only return the necessary fields               |

---

Would you like to add **FluentValidation** for validating those DTOs next, or generate DTOs for `Customer`, `Order`, and `OrderDetail` as well?

Great question, Rahman. Let’s go deep into **AutoMapper**, one of the most powerful tools for **mapping between objects**, especially **Entities ↔ DTOs** in ASP.NET Core.

---

## What Is AutoMapper?

**AutoMapper** is a library that automatically maps one object type to another.

In ASP.NET Core projects, it’s most commonly used to:
- Map between **EF Core entities and DTOs** (Data Transfer Objects)
- Eliminate repetitive `manual copying` of properties
- Keep **your domain models clean** and prevent **over-posting/exposing** internal data

---

## Why Use AutoMapper?

Without AutoMapper:

```csharp
var dto = new ProductDto
{
    Id = product.Id,
    Name = product.Name,
    Price = product.Price,
    Status = product.Status.ToString()
};
```

With AutoMapper:

```csharp
var dto = _mapper.Map<ProductDto>(product);
```

Less code, less error, more readable.

---

## How to Use AutoMapper with DTOs – Step by Step

Let’s walk through a **real example** using a `Product` entity and three DTOs.

### Step 1: Install AutoMapper

```bash
dotnet add package AutoMapper.Extensions.Microsoft.DependencyInjection
```

---

### Step 2: Define Entity and DTOs

#### Product Entity

```csharp
public class Product
{
    public int ProductId { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public ProductStatus Status { get; set; }
}
```

#### Product DTOs

```csharp
public class ProductDto  // Output
{
    public int ProductId { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string Status { get; set; } = "Active";
}

public class ProductCreateDto  // Input
{
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
}

public class ProductUpdateDto  // Input
{
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string Status { get; set; } = "Active";
}
```

---

### Step 3: Create an AutoMapper Profile

Create a file: `MappingProfiles/ProductProfile.cs`

```csharp
using AutoMapper;

public class ProductProfile : Profile
{
    public ProductProfile()
    {
        // Entity → DTO
        CreateMap<Product, ProductDto>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

        // DTO → Entity (for POST)
        CreateMap<ProductCreateDto, Product>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => ProductStatus.Active));

        // DTO → Entity (for PUT)
        CreateMap<ProductUpdateDto, Product>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => Enum.Parse<ProductStatus>(src.Status)));
    }
}
```

---

### Step 4: Register AutoMapper in `Program.cs`

```csharp
builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
```

This will scan the assembly for all profiles and load them automatically.

---

### Step 5: Use AutoMapper in Controller

```csharp
[ApiController]
[Route("api/[controller]")]
public class ProductsController : ControllerBase
{
    private readonly IProductRepository _repo;
    private readonly IMapper _mapper;

    public ProductsController(IProductRepository repo, IMapper mapper)
    {
        _repo = repo;
        _mapper = mapper;
    }

    [HttpGet("{id}")]
    public async Task<IActionResult> Get(int id)
    {
        var product = await _repo.GetByIdAsync(id);
        if (product == null) return NotFound();

        var dto = _mapper.Map<ProductDto>(product);
        return Ok(dto);
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] ProductCreateDto dto)
    {
        var product = _mapper.Map<Product>(dto);
        await _repo.AddAsync(product);
        await _repo.SaveAsync();

        var result = _mapper.Map<ProductDto>(product);
        return CreatedAtAction(nameof(Get), new { id = result.ProductId }, result);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> Update(int id, [FromBody] ProductUpdateDto dto)
    {
        var product = await _repo.GetByIdAsync(id);
        if (product == null) return NotFound();

        _mapper.Map(dto, product);  // updates existing object
        await _repo.SaveAsync();

        return NoContent();
    }
}
```

---

## Recap: What AutoMapper Does for You

| Without AutoMapper         | With AutoMapper                     |
|----------------------------|-------------------------------------|
| Manually map properties    | Uses configuration via `Profile`    |
| More repetitive code       | Clean, one-liner `Map<T>` calls     |
| Easy to miss properties    | Fully automated mapping             |
| Harder to maintain         | Easier to update and scale mappings |

---

Would you like to see how to customize mappings for nested objects, flattening, or reverse mappings (DTO → Entity → DTO roundtrip)?

Absolutely, Rahman. Let’s deep-dive into **AutoMapper Profile**, which is the **core configuration class** where all your mapping rules live.

---

## What Is an AutoMapper `Profile`?

A `Profile` is a class that inherits from `AutoMapper.Profile` and is used to define **how two types are mapped** in AutoMapper.

Instead of writing mapping code in multiple places, you centralize everything in a Profile.

---

## Why Use a Profile?

- Keeps all mappings **organized and clean**
- AutoMapper **auto-discovers** and registers profiles
- Makes mapping **testable, modular, and scalable**
- Required when registering with `AddAutoMapper()`

---

## Basic Structure of a Profile

```csharp
using AutoMapper;

public class ProductProfile : Profile
{
    public ProductProfile()
    {
        // Mapping rules go here
    }
}
```

Each `CreateMap<TSource, TDestination>()` call inside the constructor tells AutoMapper how to map one type to another.

---

## Profile in Action: Full Example

### Let's say we have:

#### Entity

```csharp
public class Product
{
    public int ProductId { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public ProductStatus Status { get; set; }
}
```

#### DTOs

```csharp
public class ProductDto
{
    public int ProductId { get; set; }
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string Status { get; set; } = "Active";
}

public class ProductCreateDto
{
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
}

public class ProductUpdateDto
{
    public string Name { get; set; } = null!;
    public decimal Price { get; set; }
    public string Status { get; set; } = "Active";
}
```

---

### ProductProfile.cs

```csharp
using AutoMapper;

public class ProductProfile : Profile
{
    public ProductProfile()
    {
        // Entity → DTO
        CreateMap<Product, ProductDto>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => src.Status.ToString()));

        // DTO → Entity (POST)
        CreateMap<ProductCreateDto, Product>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(_ => ProductStatus.Active));

        // DTO → Entity (PUT)
        CreateMap<ProductUpdateDto, Product>()
            .ForMember(dest => dest.Status, opt => opt.MapFrom(src => Enum.Parse<ProductStatus>(src.Status)));
    }
}
```

---

## Explanation of Mapping Rules

### `CreateMap<Product, ProductDto>()`

- Maps all matching fields by name
- Overrides `Status` to convert from `enum → string`

### `.ForMember(dest => dest.Status, opt => opt.MapFrom(...))`

- Customizes how the field is mapped
- `MapFrom` accepts a lambda that lets you define transformation logic

### `Enum.Parse<>()`

- Converts the input string from the `UpdateDto` to an enum back

---

## Registering Profiles

AutoMapper automatically scans and loads all profiles when you do this in `Program.cs`:

```csharp
builder.Services.AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies());
```

You don't need to manually register each profile. Just make sure they inherit from `Profile` and are in the same project or referenced assemblies.

---

## When to Use Multiple Profiles

You should create **one profile per domain entity or feature** to keep things modular. Example:

```
MappingProfiles/
├── ProductProfile.cs
├── CustomerProfile.cs
├── OrderProfile.cs
```

Each profile defines the mappings related to its concern only.

---

## Summary

| Concept            | Description                                             |
|--------------------|---------------------------------------------------------|
| `Profile` class     | Central config point for all mapping rules             |
| `CreateMap<T, T>`   | Defines source → destination mappings                  |
| `ForMember()`       | Customize property mapping                             |
| Used in Controller | `mapper.Map<DTO>(entity)` for transformation            |
| Registered via      | `AddAutoMapper(AppDomain.CurrentDomain.GetAssemblies())` |

---

Would you like to now create profiles for other entities like `Customer` or `Order`, or walk through testing your AutoMapper profile with unit tests?


Perfect timing, Rahman. Let’s integrate **FluentValidation** into your API to validate DTOs cleanly and powerfully.

FluentValidation:
- Is a popular, clean library for validating C# objects (especially DTOs).
- Gives you full control with fluent syntax instead of cluttering models with `[Required]`, `[Range]`, etc.
- Works smoothly with `ApiController` and model binding in ASP.NET Core.

---

## What We’ll Do

1. Install FluentValidation
2. Create validators for `ProductCreateDto` and `ProductUpdateDto`
3. Register FluentValidation in the service container
4. See automatic validation in action

---

## 1. Install FluentValidation NuGet Package

```bash
dotnet add package FluentValidation.AspNetCore
```

---

## 2. Create Validators

### Folder Structure

```
ECommerceApi/
├── Validators/
│   ├── ProductCreateDtoValidator.cs
│   └── ProductUpdateDtoValidator.cs
```

### `ProductCreateDtoValidator.cs`

```csharp
using FluentValidation;

public class ProductCreateDtoValidator : AbstractValidator<ProductCreateDto>
{
    public ProductCreateDtoValidator()
    {
        RuleFor(p => p.Name)
            .NotEmpty().WithMessage("Product name is required.")
            .MaximumLength(100);

        RuleFor(p => p.Price)
            .GreaterThan(0).WithMessage("Price must be greater than zero.");
    }
}
```

---

### `ProductUpdateDtoValidator.cs`

```csharp
using FluentValidation;

public class ProductUpdateDtoValidator : AbstractValidator<ProductUpdateDto>
{
    public ProductUpdateDtoValidator()
    {
        RuleFor(p => p.Name)
            .NotEmpty().WithMessage("Product name is required.")
            .MaximumLength(100);

        RuleFor(p => p.Price)
            .GreaterThanOrEqualTo(0);

        RuleFor(p => p.Status)
            .Must(s => Enum.TryParse<ProductStatus>(s, out _))
            .WithMessage("Invalid product status.");
    }
}
```

---

## 3. Register FluentValidation in `Program.cs`

```csharp
builder.Services.AddControllers()
    .AddFluentValidation(fv => fv.RegisterValidatorsFromAssemblyContaining<Program>());
```

This automatically picks up any validators in your project.

---

## 4. Use the API — Validation Happens Automatically

Your controller stays **unchanged**.

If you send a bad request:

```json
{
  "name": "",
  "price": -1
}
```

You get:

```json
{
  "errors": {
    "Name": ["Product name is required."],
    "Price": ["Price must be greater than zero."]
  }
}
```

---

## Summary of FluentValidation Power

| Feature                  | Advantage                                    |
|--------------------------|----------------------------------------------|
| No attributes in models  | Keeps DTOs clean                             |
| Fluent chaining          | More readable and powerful than data annotations |
| Automatic integration    | Validation happens before controller executes |
| Easy to test             | Validators are just plain classes            |

---

Would you like to add **custom validators** (e.g., validate against database), or apply FluentValidation to `Customer` and `Order` DTOs as well?